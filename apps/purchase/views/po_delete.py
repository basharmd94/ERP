from django.http import JsonResponse
from django.contrib.auth.decorators import login_required
from django.views.decorators.http import require_POST
from django.db import connection, transaction
import logging

logger = logging.getLogger(__name__)


@login_required
@require_POST
def po_delete(request, po_number: str):
    """
    Delete a purchase order and all tightly coupled records in a single, atomic operation.

    This function enforces a strict deletion order to maintain referential and
    business integrity across accounting and inventory modules:
      1) GL entries (detail then header) linked by vouchers referenced from GRNs
      2) Inventory movements tied to GRN document numbers
      3) GRN details and header
      4) PO details and header

    Concurrency control:
      - Uses `SELECT ... FOR UPDATE` to obtain row-level locks on `poord` and `pogrn`
        ensuring no concurrent confirm/delete can race with this operation.
      - Entire workload runs inside `transaction.atomic()` so any failure triggers
        a full rollback, leaving the system consistent.

    Security and scoping:
      - All queries are scoped by `zid` from the authenticated session.
      - Parameterized SQL is used to prevent injection and ensure safe execution.
    """
    zid = request.session.get('current_zid')
    if not zid:
        return JsonResponse({'success': False, 'message': 'Session ZID not found'}, status=401)

    try:
        # Begin an atomic transaction; any exception rolls back all changes.
        with transaction.atomic():
            with connection.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT xpornum
                    FROM poord
                    WHERE zid = %s AND xpornum = %s
                    FOR UPDATE
                    """,
                    [zid, po_number],
                )
                # Lock the PO header row to prevent concurrent modifications during deletion.
                po_row = cursor.fetchone()
                if not po_row:
                    return JsonResponse({'success': False, 'message': 'Purchase order not found'}, status=404)

                cursor.execute(
                    """
                    SELECT xgrnnum, xref
                    FROM pogrn
                    WHERE zid = %s AND xpornum = %s
                    FOR UPDATE
                    """,
                    [zid, po_number],
                )
                # Lock all GRN headers linked to this PO and gather identifiers used downstream.
                grn_rows = cursor.fetchall() or []
                grn_numbers = [row[0] for row in grn_rows if row and row[0]]
                # Many deployments store the GL voucher reference in GRN.xref; adjust here if different.
                vouchers = [row[1] for row in grn_rows if row and row[1]]

                if vouchers:
                    # Lock GL headers to prevent concurrent postings/reversals.
                    cursor.execute(
                        """
                        SELECT xvoucher
                        FROM glheader
                        WHERE zid = %s AND xvoucher IN %s
                        FOR UPDATE
                        """,
                        [zid, tuple(vouchers)],
                    )
                    # Delete GL line items first to satisfy FK constraints and keep accounting consistent.
                    cursor.execute(
                        """
                        DELETE FROM gldetail
                        WHERE zid = %s AND xvoucher IN %s
                        """,
                        [zid, tuple(vouchers)],
                    )
                    # Remove GL headers after details.
                    cursor.execute(
                        """
                        DELETE FROM glheader
                        WHERE zid = %s AND xvoucher IN %s
                        """,
                        [zid, tuple(vouchers)],
                    )

                if grn_numbers:
                    # Remove inventory movements generated by GRNs; uses GRN number as document id.
                    cursor.execute(
                        """
                        DELETE FROM imtrn
                        WHERE zid = %s AND xdocnum IN %s
                        """,
                        [zid, tuple(grn_numbers)],
                    )
                    # Delete GRN detail lines prior to header to satisfy FK relationships.
                    cursor.execute(
                        """
                        DELETE FROM pogdt
                        WHERE zid = %s AND xgrnnum IN %s
                        """,
                        [zid, tuple(grn_numbers)],
                    )
                    # Delete GRN headers after details.
                    cursor.execute(
                        """
                        DELETE FROM pogrn
                        WHERE zid = %s AND xgrnnum IN %s
                        """,
                        [zid, tuple(grn_numbers)],
                    )

                # Finally, delete PO details then header to maintain referential order.
                cursor.execute(
                    """
                    DELETE FROM poodt
                    WHERE zid = %s AND xpornum = %s
                    """,
                    [zid, po_number],
                )
                cursor.execute(
                    """
                    DELETE FROM poord
                    WHERE zid = %s AND xpornum = %s
                    """,
                    [zid, po_number],
                )

        # Structured audit log provides traceable identifiers for operations.
        logger.info(
            "PO delete completed",
            extra={
                'po_number': po_number,
                'zid': zid,
                'deleted_grns': grn_numbers,
                'deleted_vouchers': vouchers,
            },
        )
        return JsonResponse(
            {
                'success': True,
                'message': f'Purchase order {po_number} deleted successfully',
                'deleted_records': {
                    'gl_vouchers': vouchers,
                    'grn_numbers': grn_numbers,
                },
            }
        )
    except Exception as e:
        # Any exception will propagate out of the atomic block, triggering a rollback.
        logger.exception(f"Error deleting PO {po_number}: {e}")
        return JsonResponse({'success': False, 'message': 'Error deleting purchase order'}, status=500)
